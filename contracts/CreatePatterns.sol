//SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
pragma experimental ABIEncoderV2;

import "./CreatePatternsInternal.sol";
import "./LibPatterns.sol";
import "./access/AccessControlEnumerable.sol";
import "./security/Pausable.sol";
import "@solidstate/contracts/access/Ownable.sol";
import "@solidstate/contracts/token/ERC721/ERC721.sol";
import "@solidstate/contracts/token/ERC721/metadata/ERC721MetadataStorage.sol";
import "@solidstate/contracts/token/ERC721/base/ERC721BaseStorage.sol";
import "@solidstate/contracts/utils/ReentrancyGuard.sol";
import "./@rarible/royalties/contracts/impl/RoyaltiesV2Impl.sol";
import "./@rarible/royalties/contracts/LibPart.sol";
import "./@rarible/royalties/contracts/LibRoyaltiesV2.sol";
import "./ERC2981Rarible.sol";

contract CreatePatterns is
    CreatePatternsInternal,
    ReentrancyGuard,
    ERC2981Rarible,
    AccessControlEnumerable,
    ERC721,
    Pausable
{
    using Counters for Counters.Counter;
    using ERC721BaseStorage for ERC721BaseStorage.Layout;
    using EnumerableMap for EnumerableMap.UintToAddressMap;
    using EnumerableSet for EnumerableSet.UintSet;

    /**
     * @notice Require that the token has not been burned and has been minted
     */
    modifier onlyExistingToken(uint256 tokenId) {
        require(
            ERC721BaseStorage.layout().exists(tokenId),
            "CreatePatterns: nonexistent token"
        );
        _;
    }

    /**
     * @notice Ensure that the provided spender is the approved or the owner of
     * the media for the specified tokenId
     */
    modifier onlyApprovedOrOwner(address spender, uint256 tokenId) {
        require(
            _isApprovedOrOwner(spender, tokenId),
            "CreatePatterns: Only approved or owner"
        );
        _;
    }

    /**
     * @notice Ensure the token has been created (even if it has been burned)
     */
    modifier onlyTokenCreated(uint256 tokenId) {
        require(
            LibPatterns.layout().tokenIdTracker.current() > tokenId,
            "CreatePatterns: token with that id does not exist"
        );
        _;
    }

    /**
     * @notice Ensure that the provided URI is not empty
     */
    modifier onlyValidURI(string memory uri) {
        require(
            bytes(uri).length != 0,
            "CreatePatterns: specified uri must be non-empty"
        );
        _;
    }

    /**
     * @dev Creates a new token for `to`. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     *
     * See {ERC721-_mint}.
     *
     * Requirements:
     *
     * - the caller must have the `MINTER_ROLE`.
     */
    function mint(
        address to,
        LibPatterns.CreatorsPatternsMetadata memory metadata
    ) public payable virtual {
        address sender = _msgSender();
        bytes32 structHash = LibPatterns.hash(metadata);
        address creator = metadata.creator;
        if (creator != sender) {
            require(metadata.price == msg.value, "Not enough wei");
            require(metadata.expiresAt > block.timestamp, "Expired");
            LibPatterns.validateSignature(
                creator,
                structHash,
                metadata.signature
            );
        }
        require(
            hasRole(LibPatterns.MINTER_ROLE, creator),
            "CreatePatterns: must have minter role"
        );

        LibPatterns.Layout storage l = LibPatterns.layout();
        // We cannot just use balanceOf to create the new tokenId because tokens
        // can be burned (destroyed), so we need a separate counter.
        uint256 currentId = l.tokenIdTracker.current();
        _mint(to, currentId, creator);
        l.tokenIdTracker.increment();
        _setRoyalties(currentId, payable(creator), 1000);

        _setTokenURI(currentId, metadata.tokenURI);
    }

    function _mint(
        address to,
        uint256 tokenId,
        address minter
    ) internal virtual {
        require(to != address(0), "ERC721: mint to the zero address");
        ERC721BaseStorage.Layout storage l = ERC721BaseStorage.layout();
        require(!l.exists(tokenId), "ERC721: token already minted");

        _beforeTokenTransfer(address(0), to, tokenId);

        l.holderTokens[to].add(tokenId);
        l.tokenOwners.set(tokenId, to);

        if (minter != to) {
            emit Transfer(address(0), minter, tokenId);
            emit Transfer(minter, to, tokenId);
        } else {
            emit Transfer(address(0), to, tokenId);
        }
    }

    /**
     * @dev Pauses all token transfers.
     *
     * See {ERC721Pausable} and {Pausable-_pause}.
     *
     * Requirements:
     *
     * - the caller must have the `PAUSER_ROLE`.
     */
    function pause() public virtual {
        require(
            hasRole(LibPatterns.PAUSER_ROLE, _msgSender()),
            "CreatePatterns: must have pauser role to pause"
        );
        _pause();
    }

    /**
     * @dev Unpauses all token transfers.
     *
     * See {ERC721Pausable} and {Pausable-_unpause}.
     *
     * Requirements:
     *
     * - the caller must have the `PAUSER_ROLE`.
     */
    function unpause() public virtual {
        require(
            hasRole(LibPatterns.PAUSER_ROLE, _msgSender()),
            "CreatePatterns: must have pauser role to unpause"
        );
        _unpause();
    }

    /**
     * @dev Burns `tokenId`. See {ERC721-_burn}.
     *
     * Requirements:
     *
     * - The caller must own `tokenId` or be an approved operator.
     */
    function burn(uint256 tokenId) public virtual {
        //solhint-disable-next-line max-line-length
        require(
            _isApprovedOrOwner(_msgSender(), tokenId),
            "CreatePatterns: caller is not owner nor approved"
        );
        _burn(tokenId);

        ERC721MetadataStorage.Layout storage l = ERC721MetadataStorage.layout();
        if (bytes(l.tokenURIs[tokenId]).length != 0) {
            delete l.tokenURIs[tokenId];
        }
    }

    function setTokenURI(uint256 tokenId, string calldata tokenURI)
        external
        nonReentrant
        onlyApprovedOrOwner(msg.sender, tokenId)
        onlyValidURI(tokenURI)
    {
        _setTokenURI(tokenId, tokenURI);
    }

    function setBaseURI(string memory baseURI_) external onlyOwner {
        ERC721MetadataStorage.layout().baseURI = baseURI_;
    }
}
